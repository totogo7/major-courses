# 第四章 存储器管理

[TOC]



## 程序的装入和链接

用户程序要在系统中运行，必须先将它装入内存，然后再将其转变为一个可以执行的程序。通常需要：

1. 编译：形成若干个目标模块
2. 链接：由链接程序将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的装入模块。
3. 装入：由装入程序将装入模块装入内存

![image-20241020170521935](%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20241020170521935.png)

### 程序的装入

#### 1. 绝对装入方式

- **只适用于单道程序环境**
- 在编译时，如果知道程序将放到内存中的哪个位置，编译程序将**产生绝对地址的目标代码**。
- 装入程序按照装入模块中的地址，将程序和数据装入内存。

#### 2. 可重定位装入方式

- 编译、链接后的装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。
- 可根据内存的当前情况，将装入模块装入到内存的适当位置。
- 装入时对地址进行 “重定位”，将**逻辑地址变换为物理地址（地址变换是在装入时一次完成的）**

静态重定位的特点是在一个作业装入内存时，**必须分配其要求的全部内存空间**，如果没有足够的内存，就不能装入该作业。

> 作业一旦进入内存后，**在运行期间就不能再移动**，也**不能再申请内存空间**。

#### 3. 动态运行时的装入方式

- 装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是**把地址转换推迟到程序真正要执行时才进行**。
- 因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个**重定位寄存器**的支持

**重定位寄存器**: 存放装入模块存放的起始地址（基地址）

> 采用动态重定位时**允许程序在内存中发生移动**, 并且可以**动态申请空间**



### 程序的链接

1. **静态**链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。
2. **装入时动态**链接：将各目标模块装入内存时，边装入边链接的链接方式。
3. **运行时动态**链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。

## 连续分配管理方式

为了能将用户程序装入内存，必须为它分配一定大小的内存空间。连续分配方式为一个用户程序分配一个连续的内存空间。

连续分配方式可分成四类：单一连续分配、固定分区分配、动态分区分配

动态可重定位分区分配算法四种方式。

### 单一连续分配

内存被分为**系统区和用户区**

内存中**只有一道用户程序**，即整个内存的用户空间由该程序独占。

- 优点：
  1. 实现简单；
  2. 无外部碎片；
  3. 可以采用覆盖技术扩充内存；
  4. 不一定需要内存保护;
- 缺点：
  1. 只能用于单用户，单任务操作系统
  2. 有**内部碎片**
  3. 存储器利用效率极低

### 固定分区分配

为了能再内存中装入多道程序，且使这些程序之间又不会发生相互干扰，于是将整个用户空间划分成若干个固定大小的区域，在每个分区中只装入一道作业。

将用户空间划分为**若干个固定大小的分区**，在**每个分区只装入一道作业**

操作系统需要建立一个数据结构---**分区说明表**，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的**大小、起始地址、状态（是否已分配）**。

- 分区大小相等
  1. 缺乏灵活性
  2. 使用与用一台计算机控制多个相同对象
- 分区大小不等
  1. 增加了灵活性，可以满足不同大小的进程需求
- 优点：实现简单，**无外部碎片**
- 缺点：
  - 用户程序太大，需要覆盖技术来解决但又会降低性能
  - 会**产生内部碎片**，内存利用率低

### 动态分区分配

**动态分区分配**又称为**可变分区分配**。这种分配方式**不会预先划分内存分区**，而是在进程装入内存时，**根据进程的大小动态地建立分区**，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB..)

数据结构：

1. 空闲分区表：记录每个空闲分区的情况
2. 空闲分区链：在每个分区的起始部分设置一些用于控制分区分配的信息，以及用于链接各分区所用的前向指针，分区末尾设置后向指针。

注意内存回收时的各种情况，对分区表的修改情况

- **无内部碎片，有外部碎片**



### 基于顺序搜索的动态分区分配算法

为了实现动态分区分配，通常是将系统中的空闲分区链接成一个链。顺序搜索是依次搜索空闲分区上的空闲分区，寻找一个大小满足要求的分区

#### 首次适应算法

- 算法思想：每次都**从低地址开始查找**，找到第一个能满足大小的空闲分区
- 如何实现：**空闲分区以地址递增的次序排列**。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。
- 优点：优先利用内存中低址部分的空闲分区，从而保留了高址部分的大空闲区
- 缺点：低址部分不断被划分，会留下许多难以利用的，很小的空闲分区

#### 循环首次适应算法

- 算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。
- 如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
- 如何实现：空闲分区**以地址递增的顺序排列（可排成一个循环链表）**,每次分配内存时从**上次查找结束的位置开始查找空闲分区链（或空闲分区表）**，找到大小能满足要求的第一个空闲分区
- 优点：能使内存中的空闲分区分布得更加均匀，从而减少了查找空闲分区时的开销
- 缺点：缺乏大的空闲分区

#### 最佳适应算法

- 算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区
- 如何实现：空闲分区**按容量递增次序链接**。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。
- **缺点**：每次选最小的分区分配，会留下越来越多，很小的，难以利用的内存块。**因此会产生很多的外部碎片**

#### 最坏适应算法

> Largest Fit

- 算法思想：为了解決最佳适应算法的问题一一即留下太多难以利用的小碎片，可以在每次分配时
  优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。
- 如何实现：空闲分区按**容量递减次序链接**。每次分配内存时顺序查找空闲分区链（或空闲分区
  表），找到大小能满足要求的第一个空闲分区。
- 缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后**有“大进程”到达，就没有内存分区可用了**



### 基于索引搜索的动态分配算法

基于顺序搜索的动态分区分配算法， 比较适用于不太大的系统。当系统很大的时候，为了提高搜索空闲分区的速度，会使用基于索引搜索的动态分区分配算法。

#### 快速适应算法

- **基本原理**：快速适应算法是一种简单的动态内存分配算法。当进程请求内存时，系统按顺序查找内存分区列表，找到第一个足够大的空闲分区，并将其分配给进程。剩下的内存（如果有）会继续保留在空闲列表中。
- 优点：
  - 实现简单，易于理解。
  - 分配速度快，尤其是首次适应（First Fit）算法。
- 缺点：
  - 会造成内存碎片。
  - 查找时有可能效率较低，尤其在空闲内存分区过多时。
  - 随着时间推移，内存的利用率下降。

#### 伙伴系统

- **基本原理**：伙伴系统将内存按2的幂次方划分。当需要分配内存时，从合适的大小块中选择一个最接近需求大小的块。如果合适大小的块不可用，会分裂较大的块为两个“伙伴”，并分配一个给进程。未用的另一个块继续可用。当分配的内存被释放时，系统会尝试与其伙伴合并，恢复为更大的块。
- 优点：
  - 减少了内存碎片问题。
  - 分裂和合并操作较为高效。
- 缺点：
  - 内存分配可能不够精确，会造成一定的浪费（内部碎片）。
  - 合并操作有时会引发额外的时间消耗。

#### 哈希算法

- **基本原理**：通过哈希函数，将内存地址或大小映射到一个特定的位置进行管理。每个内存块根据其哈希值快速查找或插入。哈希算法主要用于加快索引查找的速度，减少查找时间复杂度。
- 优点：
  - 查找速度快，平均时间复杂度为O(1)。
  - 哈希表能高效地处理内存分配和回收。
- 缺点：
  - 需要额外的空间来维护哈希表。
  - 当哈希冲突频繁发生时，性能可能退化。
  - 哈希表的设计较为复杂，调试和维护成本较高。

## 对换（Swapping）

对换：是指把内存中暂时不能运行的进程或者暂时不用的程序和数据换出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据换入内存。

- 在具有对换功能的OS中，通常把磁盘空间分为文件区和对换区

1）对文件区管理：对文件区管理的主要目标是提高文件存储空间的利用率，因此对文件区空间的管理采用**离散分配**方式。

2）对对换空间管理：对对换空间管理的主要目标是提高进程换入和换出的速度，因此对对换空间的管理采用**连续分配**方式



## 分页存储管理方式*

> 非连续分配方式

将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个 **“页框”，或称“页帧”、“内存块”、“物理块”** 。每个页框有一个编号，即 **“页框号”，“内存块号”，“页帧号”、“物理块号”**，页框号**从 00 开始**

- 将用户进程的地址空间也分为**与页框大小相等**的一个个区域称为 **“页”或“页面”**。每个页面也有一个编号，即“页号”。
- **页号也是从0开始**。(注：进程的**最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片**）

操作系统**以页框为单位为各个进程分配**内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的**页面**与内存的**页框**有**一一对应**的关系。

各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。

1. 要算出逻辑地址对应的页号
2. 要知道该页号对应页面在内存中的起始地址
3. 要算出逻辑地址在页面内的“偏移量”
4. 物理地址=页面始址 ＋页内偏移量

### 地址结构

分页地址中的地址结构：

![image-20241020174611689](%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20241020174611689.png)



### 页表

1. 一个进程对应一张页表
2. 进程的每一页对应一个页表项
3. 每个**页表项**由“页号”和“块号” 组成
4. 页表记录**进程页面和实际存放的内存块之间的对应关系**
5. 每个页表项的长度是相同的，**页号是“隐含”的**

![image-20241020174638952](%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20241020174638952.png)

### 地址变换机构

为了能够将用户地址空间中的**逻辑地址转换为内存空间中的物理地址**，在系统中必须设置地址变换机构。

> 地址变换任务是借助于页表完成的

#### 基本的地址变换机构

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。

- 在系统中设置一个页表基地址寄存器（PTBR），存放页表在内存中的起始地址F 和页表长度M.

进程末执行时，页表的始址 和 页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

![image-20241020174942192](%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20241020174942192.png)

- 页表寄存器作用
  - 存放页表起始地址
  - 存放页表长度
- 地址变换过程
  1. 根据逻辑地址算出页号、页内地址
  2. 页号的合法性检查
  3. 若页号合法，再根据页表起始地址、页号找到对应页表项
  4. 根据页表项中记录的内存块号、页内地址的到最终的物理地址
  5. 访问物理内存对应的内存单元



#### 具有快表的地址变换机构

- **时间局部性：** 如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）
- **空间局部性：** 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）

**快表，又称联想寄存器 (TLB)**，是一种**访问速度比内存快很多**的高速缓冲存储器，用来**存放当前访问的若干页表项**，以加速地址变换的过程。与此对应，内存中的页表常称为**慢表。**



==访问内存的有效时间==

> 从进程发出指定逻辑地址的访问请求，经过地址变换，到再内存中找到对应的实际物理地址单元并取出数据，所花费的总时间，成为内u你的有效访问时间。



### 两级和多级页表

那么单级页表的问题：

1. 页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。
2. 没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。

#### 解决连续存放的问题

> 采用离散分配方式

我们可以把页表放在不同的页框中，再用一个表来记录各个各个子页表所在位置，我们把这个表叫做**外层页表。**

#### 两级页表结构

![image-20241020180200665](%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20241020180200665.png)

- 页表的每个表项中存放的是进程的某页在内存中的物理块号。

- 外层页表的每个页表项存放的是某页表分页的首地址

#### 两级页表的地址变换机构

增设一个外层页表寄存器，用于存放外层页表的始址。

![image-20241020180501523](%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20241020180501523.png)

#### 解决访问特定页面问题

在需要访问页面时才把页面调入内存，可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。（虚拟存储器会详细说）



tips：

> 1. 若采用多级页表机制，则各级页表的大小不能超过一个页面



## 分段存储管理方式

进程的地址空间:**按照程序自身的逻辑关系划分为若干个段**，每个段都有一个段名（在低级语言中，程序员使用段名来编程)，每段从0开始编址。

内存分配规则 : 以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。

### 分段地址

![image-20241020180855062](%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20241020180855062.png)

- 段号的位数决定了每个进程最多可以分几个段。
- 段内地址位数决定了每个段的最大长度是多少。
- 这里表示一个作业最长有64K个段，每个段最大程度64KB

### 段表

每个段对应一个段表向，记录了该段在内存中的起始位置和段的长度。

![image-20241020181112496](%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20241020181112496.png)

### 地址变换机构

在系统中设置了段表寄存器，用于存放段表始址和段表长度TL。

![image-20241020181250340](%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20241020181250340.png)

变换过程

- 根据逻辑地址得到段号(2)、段内地址

- 判断段号是否越界

- 查询段表，找到对应的段表项

- 检查段内地址是否超过段长(上图中段号2的段长500)

- 计算得到物理地址(基址+位移量)

- 访问目标内存单元

  

### 分段，分页对比
- 页是信息的物理单位。**分页的主要目的是为了实现离散分配，提高内存利用率。**分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。
- 段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。
- 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。
- 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。
- 分段比分页更容易实现信息的共享和保护
  

以下是对分页和分段的对比分析表：

| 比较维度       | 分页                                                   | 分段                                         |
| -------------- | ------------------------------------------------------ | -------------------------------------------- |
| **定义**       | 页是信息的物理单位，主要用于提高内存利用率             | 段是信息的逻辑单位，旨在更好地满足用户需求   |
| **目的是**     | 为了实现离散分配，提高内存利用率，系统行为对用户不可见 | 更好满足用户需求，用户可以看到和使用段       |
| **用户可见性** | 对用户不可见，分页是系统行为                           | 对用户可见，用户需要显式指定段名             |
| **大小**       | 页的大小固定，由系统决定                               | 段的大小不固定，由用户编写的程序决定         |
| **地址空间**   | 用户进程地址空间是一维，使用单一地址进行访问           | 用户进程地址空间是二维，需要段名和段内地址   |
| **共享与保护** | 相对较难实现信息的共享与保护                           | 更容易实现信息的共享与保护                   |
| **管理复杂度** | 简单，系统自动处理页表                                 | 较复杂，系统需要管理段表和段的权限           |
| **适用场景**   | 适合物理内存分配优化，提高内存利用率                   | 适合程序模块化、数据结构化的场景，更具灵活性 |



### 信息共享

分段比分页更容易实现信息的共享和保护。

![image-20241020182014781](%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20241020182014781.png)

共享editor，只需要在进程1和进程2的段表中，为文本编辑程序设置一个段表项，让段表项中的基址(80)指向editor程序在内存的起始地址。

> 注意：必须是可重入代码才可以共享。可重入代码是一种不允许任何进程对它进行修改的代码



## 段页式存储管理方式

分页、分段优缺点：

|          | 优点                                                     | 缺点                                                         |
| -------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 分页管理 | 内存空间利用率高，**不会产生外部碎片**，只有少量页内碎片 | 不方便按照逻辑模块实现信息的共享和保护                       |
| 分段管理 | 很方便按照逻辑模块实现信息的共享和保护                   | 如果段长过大， 为其分配很大的连续空间会很不方便，而且**会产生外部碎片** |

因此段页式系统基本原理时分段和分页原理的结合，先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。

### 逻辑地址结构: 

![image-20241020182551679](%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20241020182551679.png)

每个段对应段表项，各表项长度相同段表组成： (段号、页表长度、页表存放地址)

每个页对应一个页表项，页表组成：（页号、页面存放的内存块号）

### 地址变换过程

- 需要配置一个段表寄存器，存放段表始址和段长TL

![image-20241020182911440](%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86.assets/image-20241020182911440.png)

过程：

- 根据逻辑地址的到段号、页号、页内偏移量
- 判断段号是否越界
- 查询段表，找到对应段表项（第一次访存）
- 检查页号是否越界
- 根据页表存放块号、页号查询页表找到对应页表项（第二次访存）
- 根据内存块号、页内偏移量找到物理地址
- 访问目标内存单元（第三次访存）



---

日期：2024.10.20

耗时：1h35min

修正次数：0