# 第三章 处理机调度与死锁

## 处理机调度层次

**1. 高级调度(作业调度)**

- 由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序
- 按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业给他们分配内存等必要资源，**建立相应的进程（建立PCB）**，以使它（们）**获得竞争处理机的权利**。
- 高级调度是**辅存（外存）与内存**之问的调度。每个作业只调入一次，调出一次。**作业调入时会建立相应的PCB，作业调出时才撤销PCB**。
  高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

**2. 中级调度(内存调度)**

- 就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此中级调度**发生的频率要比高级调度更高**。
- 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了**提高内存利用率和系统吞吐量**。
- 暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程**PCB会被放到的挂起队列**中。

**3. 低级调度(进程调度)**

- 其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它
- 讲程调度是操作系统中 **最基本的一种调度，** 在一般的操作系统中都必须配置进程调度。
- 进程调度的**频率很高**，一般几十毫秒一次。

## 调度算法的评价指标

1. CPU利用率

$$
CPU利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}
$$

2. 系统吞吐量

   吞吐量是指单位时间内系统所完成的作业数。

3. 周转时间

   指**从作业被提交给系统开始**, 到**作业完成为止**这段时间间隔

   包括四个部分

   - 作业在**外存后备队列**上等待作业调度（高级调度）的时间、
   - 进程在就绪队列上等待进程调度（低级调度）的时间、
   - 进程在CPU上执行的时间、
   - 进程等待I/O操作完成的时间。

$$
周转时间=作业完成时间-作业提交时间\\
平均周转时间=\frac{各作业周转时间之和}{作业数}\\
带权周转时间=\frac{作业周转时间}{作业实际运行时间}\\
平均带权周转时间=\frac{各作业带权周转时间之和}{作业数}
$$

4. 等待时间

   对于进程, 就是在处理机上等待时间总和

   对于作业, 还要计算上作业在外存等待队列上等待的时间

5. 响应时间

   从用户**提交请求**到**首次产生响应**所产生的时间



## 批处理调度算法

### 1. 先来先服务（FCFS）

- 思想: 先来先得
- 规则: 按照到达先后顺序服务
- 作业/进程调度: 都能使用, 作业调度考虑谁先到后背队列, 进程调度考虑谁先到就绪队列
- 抢占: **非抢占式**
- 优点: 公平, 实现简单
- 缺点: **对长作业有利, 短作业不利**
- 饥饿: 不会导致饥饿

等待时间 = 周转时间 - 运行时间 - I/O 操作时间

### 2. 短作业优先（SJF）

- 思想: 追求最少的平均等待时间, 平均周转时间, 平均带权周转时间
- 规则: 最短的作业/进程优先得到服务(**服务时间最短**)
- 作业/进程调度: 两者都可以, 用于进程时称为 "短进程优先 (SPF, *Shortest Process First*)" 算法
- 抢占: 默认**非抢占式**, 也有**抢占式---最短剩余时间优先**算法 (SRTN, *Shortest Remaining Time Next*)
- 优点: "最短" 平均等待时间, 周转时间
- 缺点: **对短作业有利, 长作业不利**
- 饥饿: **会发生饥饿**

### 3. 高响应比优先算法（HRRN）

- 思想: 总和考虑等待时间和要求服务时间
- 规则: 每次调度时计算各个作业/进程的响应比, 选择最高的来服务
  - 公式: $$响应比= \frac{\text{等待时间} + \text{服务时间}}{\text{服务时间}} = 1 + \frac{\text{等待时间}}{\text{服务时间}}$$				
- 作业/进程调度: 都能使用
- 抢占: **非抢占式**, 当前运行作业/进程主动放弃处理机才进行调度
- 优点: 综合考虑, 结合了 SJF 和 FCFS 的优点
- 缺点: 无
- 饥饿: 不会导致饥饿

三种算法总结, 均**不适合交互式系统**!



## 交互式系统调度算法

### 1. 时间片轮转RR

- 思想: 公平轮流服务, 每个进程在一定时间间隔内都得到响应
- 规则: 按照各进程到就绪队列顺序, 轮流让各进程执行一个 **时间片** (如100ms), 时间片结束未执行完成将被剥夺处理机, 放到队尾
- 作业/进程调度: **进程调度**, 作业放入内存建立了进程才能被分配时间片
- 抢占: **抢占式**, 时钟装置产生**时钟中断**进行时间片轮转
- 优点: 公平,响应快, 适用分时操作系统
- 缺点: 高频率进程切换, 不区分任务紧急程度
- 饥饿: 不会导致饥饿

同一时刻两个进程 A 和 B, A 刚下处理机, B 刚进入队列, **默认** B 先轮转时间片

如果**时间片太大**, **退化为FCFS**, **会增大进程响应时间**

如果**时间片太小**, **进程切换频繁**, 切换进程会花费大量时间

一般来说, 设计时间片要让切换进程的开销占比**不超过 1%**

### 2. 优先调度算法

- 思想: 根据任务紧急程度来调度
- 规则: 每个任务有自己的优先级, 调度时选择优先级最高的
- 作业/进程调度: 都可以, 甚至还能用于 I/O 调度
- 抢占: **抢占式, 非抢占式均可**, 抢占式时就绪队列发生变化就可能要调度, 否则主动放弃处理机时调度
- 优点: 优先级区分紧急程度, 适用实时操作系统
- 缺点: 一直有高优先级进入会有饥饿
- 饥饿: **导致饥饿**

对于非抢占式优先级调度算法，一旦把处理机分配给就绪队列中优先级最高的进程后，该进程便一直执行下去直至完成。

对于抢占式优先级调度算法，只要出现了另一个优先级更高的进程，调度程序就将处理机分配给新到的优先级最高的进程。

#### 优先级类型

- 静态优先级：进程创建后，优先级一直不变。
- 动态优先级：创建进程之初先赋予一个优先级，然后其值随着进程的推进或等待时间的增加而改变。

通常策略

- 通常系统进程优先级 **高于** 用户进程
- 前台进程优先级 **高于** 后台进程
- 操作系统更**偏好I/O型进程(I/O繁忙型进程)**, 相对的是 **计算型进程(CPU繁忙进程)**, 两者可以并行, 选择更早进行 I/O 可以更优

动态策略

- 如果某进程在就绪队列中**等待了很长时间**，则可以适当**提升**其优先级
- 如果某进程占用**处理机运行了很长时间**，则可适当**降低**其优先级
- 如果发现一个进程**频繁地进行I/O操作**，则可适当**提升**其优先级

### 3. 多级反馈队列调度

- 规则:
  1. 设置多级就绪队列, 优先级**从高到低**, 时间片**从小到大**
  2. 新进程到达时**先进入第1级**队列, 按FCFS原则排队等待时间片, 如果用完时间片还未结束, 进入下一级队列队尾, 如果已经在最低级队列, 则重新放回队尾
  3. 只有**第k级**队列为空, 才会为 k+1 级队列分配时间片

- 作业/进程调度: **用于进程调度**
- 抢占: **抢占式**, 抢占式的算法。在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，**原来运行的进程放回 k 级队列队尾**。
- 优点: 结合了前面所有调度算法的优点, 并且对于 CPU密集型进程, I/O密集型进程可以调整偏好程度 (如: 将因 I/O 阻塞的进程重新放回原队列, 这样可以保证 I/O 进程保持较高优先级)
- 饥饿: **会导致饥饿**



## 死锁的概念

### 死锁定义

- **死锁**：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。
- **饥饿**：由于长期得不到想要的资源，某进程无法向前推进的现象。比如：在短进程优先 （SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”而发生长进程
- **死循环**：某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug 导致的，有时是程序员故意设计的。

### 死锁锁产生的必要条件

产生死锁**必须同时满足以下四个条件，只要其中任一条件不成立，死锁就不会发生**。

1. **互斥条件**：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）
2. **不可抢占条件**：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。
3. **请求和保持条件**：进程已经保持了至少一个资源，但又提出子新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己己有的资源保持不放。
4. **循环等待条件**：存在一种进程资源的循环等待链，链中的每一个进程己获得的资源同时被下一个进程所请求。

**发生死锁时一定有循环等待**

- 但是发生循环等待时未必死锁（**循环等待是死锁的必要不充分条件**）, 如果同类资源数大于 1，则即使有循环等待，也未必发生死锁。
- 但如果系统中每类资源都只有 1 个，那循环等待就是死锁的充分必要条件了。

### 死锁的处理策略

1. 预防死锁。破坏死锁产生的四个必要条件中的一个或几个。
2. 避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）
3. 检测死锁。允许进程在运行过程中发生死锁，但可以检测出死锁的发生，然后采取措施
4. 解除死锁。当检测到系统中已发生的死锁，就采取相应措施



## 预防死锁

### 1. 破坏“请求和保持”条件

#### 第一种协议

所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需要的全部资源。此时若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给它。这样该进程就不会提出资源要求了，破坏了“请求”条件。

缺点：

- 资源被严重浪费
- 使进程经常发生饥饿现象

#### 第二种协议

允许进程只获得运行初期所需的资源后，便开始运行，进程运行过程中再逐步释放已分配给自己的、且已用完的全部资源，然后再请求新的所需要的资源。



### 2. 破坏“不可抢占”条件

规定当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，必须释放已经保持的所有资源，以后再需要的时候重新申请。

缺点：

- 实现起来比较复杂
- 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。
- 反复地申请和释放资源会增加系统开销，降低系统吞吐量



### 3. 破坏“循环等待”条件

对系统所有资源类型进行线性排序，为每个资源类型赋予唯一的序号。

例如，假设系统中有两类资源：R1 和 R2，它们的编号分别是 1 和 2。按照资源顺序策略，一个进程如果需要 R1 和 R2，必须先请求 R1（编号1），再请求 R2（编号2）。这样可以避免循环等待。

**进程在获取资源时不能逆序**：如果一个进程已经持有编号较大的资源，它就不能请求编号较小的资源。例如，持有资源 R2 的进程不能请求 R1。如果想要请求R1，就必须释放R2，也就是如果想要请求一个序号低的资源，必须先释放所有具有相同和更高序列的资源后才可以申请。

该策略的**缺点**：

1. 不方便增加新的设备，因为可能需要重新分配所有的编号。
2. 进程实际使用资源的顺序可能和 编号递增顺序不一致，会导致资源浪费。
3. 必须按规定次序申请资源，用户编程麻烦。

## 避免死锁

> 当系统处于安全状态的时候，可以避免死锁。

**安全序列**：就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是**安全状态**。如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了**不安全状态**。

如果系统处于安全状态，就一定不会发生死锁。如果系统进入**不安全状态**，就**可能**发生**死锁**（处于不安全状态未必就是发生了死锁，但**发生死锁时一定是在不安全状态**）

### 银行家算法

银行家算法 是一种避免死锁的资源分配与死锁避免算法。它主要用于系统动态处理资源请求，保证系统在任何时刻都处于一个**安全状态**。如果分配某一进程资源会导致系统进入不安全状态，那么该请求将被拒绝。

核心思想：

1. **安全性检查**：通过判断系统当前是否处于安全状态，来决定是否批准某进程的资源请求。
2. **资源分配请求处理**：在接收到进程的资源请求时，模拟分配，检查是否可以满足请求并保持系统安全。

主要数据结构：

- `Max[i][j]`：进程 `i` 需要的最大资源量。
- `Allocation[i][j]`：进程 `i` 当前已分配的资源量。
- `Need[i][j]`：进程 `i` 还需要的资源量，计算公式：`Need[i][j] = Max[i][j] - Allocation[i][j]`。
- `Available[j]`：当前系统可用的资源量。

数据结构设计：

- **`Max[i][j]`**: 进程 `i` 需要的最大资源量 `j`。
- **`Allocation[i][j]`**: 进程 `i` 当前已经分配的资源量 `j`。
- **`Need[i][j]`**: 进程 `i` 还需要的资源量 `j`，由公式 `Need[i][j] = Max[i][j] - Allocation[i][j]` 计算得出。
- **`Available[j]`**: 当前系统可用的资源量 `j`。
- **`Request[i][j]`**: 进程 `i` 请求的资源量 `j`。

基本步骤：

- **初始化**：定义系统中的资源数量，初始化各进程的最大需求 `Max`，当前已分配的资源 `Allocation`，和系统的可用资源 `Available`。
- **资源请求**：每当有进程发出资源请求时，首先判断其请求是否合理（即 `Request` 不超过 `Need` 和 `Available`），然后尝试分配。
- **安全性检查**：假设资源已经分配，使用安全性检查算法来验证此分配是否会导致系统进入不安全状态。若安全，则批准请求；若不安全，则拒绝请求并回滚分配。

（代码参考实验二）



## 死锁的检测

为了能对系统中是否发生了死锁进行检测，需要满足：

1. 保存有关资源的请求和分配信息
2. 提供一种算法，它可以利用这些信息来检测系统是否进入了死锁状态

### 资源分配图

两种结点：

- 进程结点P={P1,P2,…,Pn}
- 资源结点R={R1,R2,…,Rn}

两种边：

- 进程结点-->资源结点 e={Pi,Rj}  表示进程Pi请求一个单位的Rj资源
- 资源结点-->进程结点 E={Rj,Pi}  表示把一个单位的资源Rj分配给进程Pi

![image-20241016222139225](%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81.assets/image-20241016222139225.png)

（上图表示E={(P1,R2),(R2,P2),(P2,R1),(R1,P1)})

此时P1进程已经分配的到两个R1资源，并请求一个R2资源；

P2进程获得一个R1和一个R2资源，请求R1资源

### 死锁定理

![image-20241016222358313](%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81.assets/image-20241016222358313.png)

将上图简化，P1进程可以获得一个R2资源继续运行，直至运行完毕，释放其所占有的全部资源。（此时如b图）

然后P2获得所需要的资源并释放资源，得到c图

> 如果图中的边都可以被消除，则称这个图是**可完全简化的**

**检测算法：**

1. 找到一个**既不是孤点也不阻塞的点**， 消除其所有边
2. 消除后释放的资源可以让某些阻塞进程被唤醒，然后继续消除这些进程的边。

**死锁定理**

- 如果某时刻系统的资源分配图是**不可完全简化**的，那么此时系统发生**死锁**

## 死锁解除

并不是所有进程都是死锁状态，用检测算法**化简资源分配图后，还连着边的进程就是死锁进程**。

主要方法：

1. **资源剥夺法**。挂起（放外存）某些进程，抢占资源重新分配给其他进程。后续注意饥饿
2. **撤销进程法（终止进程）**。付出代价可能很大，前功尽弃，但实现简单
3. **进程回退法**, 让死锁进程回退到足以避免死锁的地步，需要系统记录进程历史信息。